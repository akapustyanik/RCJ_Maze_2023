// Screen dimensions
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 128  // Change this to 96 for 1.27" OLED.

// You can use any (4 or) 5 pins

#define SCLK_PIN 51
#define MOSI_PIN 52
#define DC_PIN 50
#define CS_PIN 53
#define RST_PIN 49

// Color definitions
#define BLACK 0x0000
#define BLUE 0x001F
#define RED 0xF800
#define GREEN 0x07E0
#define CYAN 0x07FF
#define MAGENTA 0xF81F
#define YELLOW 0xFFE0
#define WHITE 0xFFFF

#define CATBUT1 47
#define CATBUT2 48

#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1351.h>

Adafruit_SSD1351 tft = Adafruit_SSD1351(SCREEN_WIDTH, SCREEN_HEIGHT, CS_PIN, DC_PIN, MOSI_PIN, SCLK_PIN, RST_PIN);

const unsigned char paw[] PROGMEM = {
  0x00, 0x3e, 0x7c, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0x80,
  0x01, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0x80, 0x07, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xf0,
  0x1f, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xfc
};

const unsigned char ears[] PROGMEM = {
  // 'ears', 42x10px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0x00,
  0x01, 0xc0, 0xe0, 0x00, 0x00, 0x00, 0x03, 0x80, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x80, 0xf0, 0x00,
  0x00, 0x00, 0x07, 0x80, 0xf0, 0x00, 0x00, 0x00, 0x07, 0x80, 0x70, 0x00, 0x00, 0x00, 0x07, 0x80,
  0x70, 0x00, 0x00, 0x00, 0x07, 0x80, 0x60, 0x00, 0x00, 0x00, 0x03, 0x00
};

const unsigned char paw2[] PROGMEM = {
  // 'cat paw2', 32x32px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x38, 0x00, 0x00, 0x3e, 0x7c, 0x00,
  0x00, 0x3e, 0x7c, 0x00, 0x00, 0x3e, 0x7c, 0x00, 0x00, 0x3e, 0x7c, 0x00, 0x00, 0x1c, 0x38, 0x00,
  0x01, 0x00, 0x00, 0x80, 0x07, 0xc0, 0x03, 0xe0, 0x07, 0xe1, 0x87, 0xe0, 0x07, 0xe7, 0xe7, 0xe0,
  0x07, 0xc7, 0xe3, 0xe0, 0x03, 0xcf, 0xf3, 0xc0, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x7f, 0xfe, 0x00,
  0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00,
  0x00, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char cat[] PROGMEM = {
  //cat 64x128
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
  0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00,
  0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x62, 0x00,
  0x00, 0x31, 0x80, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x30, 0xc0, 0x00, 0x00, 0x01, 0xc6, 0x00,
  0x00, 0x30, 0xe0, 0x00, 0x00, 0x03, 0x86, 0x00, 0x00, 0x30, 0xf0, 0x00, 0x00, 0x03, 0x86, 0x00,
  0x00, 0x38, 0xf0, 0x00, 0x00, 0x07, 0x86, 0x00, 0x00, 0x38, 0xfc, 0x00, 0x00, 0x1f, 0x86, 0x00,
  0x00, 0x39, 0xff, 0xff, 0xff, 0xff, 0xce, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xe1, 0x87, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xff, 0xe3, 0xc7, 0xff, 0xff, 0x00,
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
  0x07, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xe0, 0x1f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xf8,
  0x3f, 0xff, 0x3f, 0xff, 0xff, 0xfe, 0x7f, 0xfc, 0x7f, 0xff, 0xc1, 0xff, 0xff, 0x83, 0xff, 0xfe,
  0x7f, 0xff, 0xfe, 0x3f, 0xfc, 0x7f, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xdf, 0xfb, 0xff, 0xff, 0xfe,
  0x7f, 0xff, 0xff, 0xef, 0xf7, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xfc,
  0x1f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xc0,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xfc, 0x0f, 0xc0, 0x3f, 0xfc, 0x00,
  0x00, 0x7f, 0xf8, 0x0f, 0xc0, 0x3f, 0xfc, 0x00, 0x00, 0x7f, 0xfc, 0x0f, 0xc0, 0x3f, 0xfc, 0x00,
  0x00, 0x3f, 0xfc, 0x0f, 0xc0, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xfc, 0x0f, 0xc0, 0x3f, 0xfc, 0x00,
  0x00, 0x3f, 0xfc, 0x0f, 0xc0, 0x3f, 0xf8, 0x00, 0x00, 0x3f, 0xfc, 0x07, 0xe0, 0x3f, 0xf8, 0x00,
  0x00, 0x3f, 0xfc, 0x07, 0xe0, 0x3f, 0xf8, 0x00, 0x00, 0x1f, 0xfc, 0x07, 0xe0, 0x3f, 0xf8, 0x00,
  0x00, 0x1f, 0xfc, 0x07, 0xf0, 0x3f, 0xf0, 0x00, 0x00, 0x1f, 0xfc, 0x03, 0xf0, 0x3f, 0xf0, 0x00,
  0x00, 0x1f, 0xfc, 0x03, 0xf8, 0x3f, 0xf0, 0x00, 0x00, 0x0f, 0xfc, 0x03, 0xfc, 0x3f, 0xf0, 0x00,
  0x00, 0x0f, 0xfc, 0x01, 0xfe, 0x3f, 0xe0, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0xff, 0x3f, 0xe0, 0x00,
  0x00, 0x07, 0xfc, 0x00, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x7f, 0xff, 0xc0, 0x00,
  0x00, 0x07, 0xfc, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x1f, 0xff, 0xc0, 0x00,
  0x00, 0x03, 0xfc, 0x00, 0x07, 0x3f, 0x80, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x3f, 0x80, 0x00,
  0x00, 0x01, 0xf8, 0x00, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x1f, 0x00, 0x00
};

void setTextSize(uint8_t ts) {
  //СМОТРИ КОД ДЛЯ ДИСПЛЕЯ!!! ТУТ ДОЛЖНА БЫТЬ ПЕРЕМЕННАЯ!!! И ВООБЩЕ ТУТ НЕ ВСЕ ФУНКЦИИ И ФУНКЦИОНАЛ!!! 
  tft.setTextSize(ts);
}

#define sgn(x) ((x) < 0 ? -1 : ((x) > 0 ? 1 : 0))
#define ASCII_CONVERT '0'

int16_t minDist = 85, squareDist = 300, squareEnc = 1000, l1Dist = 35, l2Dist = 100, lateralDist = 120, l3Dist = 10, deltaL = 10;

int16_t vMinTurn = 150, vForward = 850;

float kGyroGlobal = 40, kLaser1Global = 4, kLaser2Global = 8, kViravnLaser = 7, kViravnTurn = 40, kViravnForward = 2;

void forward(int16_t v = vForward * 2, int16_t distEnc = squareEnc, float kGyro = kGyroGlobal, float kLaser1 = kLaser1Global, float kLaser2 = kLaser2Global, float kViravn1 = kViravnForward);

void turn(int8_t newOrient, int16_t vMin = vMinTurn, int16_t deltaMin = 10, float kViravn1 = kViravnTurn, float kViravn2 = kViravnLaser);

void forwardGyro(int16_t distEnc, int16_t v = vForward / 2, float kGyro = kGyroGlobal, float kLaser1 = kLaser1Global, float kLaser2 = kLaser2Global, float kViravn1 = kViravnForward);

void setID();

void read_lasers();

void oneSide(int32_t distEnc, int8_t side, int16_t v = vForward / 2);

const int8_t mazeSizeX = 15, mazeSizeY = 15, mazeSizeZ = 2;

uint8_t maze[mazeSizeX][mazeSizeY][mazeSizeZ];
int8_t xRobot = 0, yRobot = 0, zRobot = 0;
int8_t lastPitch = 0;
int16_t srednServo = 100;
int8_t allPositions[4] = { 0, 0, 0, 0 };

int16_t forwBut[2] = { 2, 3 };

#include <Wire.h>
#include "VL53L0X.h"
#include <Servo.h>
#include <EEPROM.h>
#include <Adafruit_NeoPixel.h>
#define LED_PIN 4
#define LED_COUNT 18
#define BRIGHTNESS 255

Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB);

Servo myServo;

VL53L0X lox[7];

int16_t lox_mosfets[7] = { 22, 23, 24, A13, A14, A15, -1 };

int16_t lox_adresses[7] = { 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, -1 };

int16_t lox_shts[7] = { 31, 32, 33, 30, 35, 34, -1 };

float zeroYprGlobal[3] = { 0, 0, 0 };

int16_t blackColor[2] = { 500, 900 };
int16_t blueColor[2] = { 150, 400 };
int16_t silverColor[2] = { 10, 22 };

struct DataFromSerial {
  float ypr[3];
  int32_t enc[4];
};

struct Buffer {
  float ypr[3];
  int32_t enc[4];
  byte crc;
};

struct DataToSerial {
  bool onlyPwm[4];
  int16_t vMotor[4];
  byte crc;
};

bool errSerial = 0;
bool lastHorizont = 0;
uint32_t myTimer;
const int16_t sleep = 7;
int8_t orient = 0;
float kAccelTurn = 900 / 45;
int16_t barrier[2] = { 0, -1 };

DataFromSerial fromSerial;
DataToSerial toSerial;
int8_t helps[6] = { 2, 0, 3, 0, 1, 1 };
int8_t numHelps = 0;
const int8_t numHelpsMax = 12;
int8_t nowHelps[4] = { 0, 0, 0, 0 };

int16_t lasers[6];

Buffer buf;

void setup() {
  strip.begin();  // INITIALIZE NeoPixel strip object (REQUIRED)
  strip.show();   // Turn OFF all pixels ASAP
  strip.setBrightness(BRIGHTNESS);

  for (int i = 0; i < mazeSizeX; i++) {
    for (int j = 0; j < mazeSizeY; j++) {
      for (int n = 0; n < mazeSizeZ; n++) {
        maze[i][j][n] = 0;
      }
    }
  }
  pinMode(47, INPUT_PULLUP);
  pinMode(48, INPUT_PULLUP);
  if (digitalRead(47) or digitalRead(48)) {
    EEPROM.put(0, maze);
    EEPROM.put(sizeof(maze), allPositions);
  } else {
    EEPROM.get(0, maze);
    EEPROM.get(sizeof(maze), allPositions);
    xRobot = allPositions[0];
    yRobot = allPositions[1];
    zRobot = allPositions[2];
    orient = allPositions[3];
  }
  tft.begin(0);
  SPI.setClockDivider(SPI_CLOCK_DIV2);
  tft.fillRect(0, 0, 128, 128, 0x4000);
  tft.drawBitmap(32, 0, cat, 64, 128, 0x5DD8);
  tft.fillCircle(52, 25, 2, BLACK);
  tft.fillCircle(75, 25, 2, BLACK);
  tft.drawBitmap(44, 3, ears, 42, 10, 0xE0B7);
  setTextSize(4);
  tft.setCursor(6, 50);
  tft.setTextColor(0xF000);
  tft.print("MZCAT");
  // put your setup code here, to run once:
  Serial.begin(115200);
  Wire.begin();
  float voltage = float(map(analogRead(1), 705, 926, 96, 126)) / 10.0;
  Serial.println(analogRead(1));
  //if (voltage < 10.4)
    // while (1)
    //   Serial.println(analogRead(1));
  Serial1.begin(115200);
  Serial2.begin(115200);
  Serial3.begin(115200 * 3);
  myServo.attach(5);
  myServo.write(srednServo + 10);
  delay(250);
  myServo.write(srednServo - 10);
  delay(250);
  myServo.write(srednServo);
  pinMode(forwBut[0], 2);
  pinMode(forwBut[1], 2);
  pinMode(13, 1);
  toSerial.onlyPwm[0] = toSerial.onlyPwm[1] = toSerial.onlyPwm[2] = toSerial.onlyPwm[3] = 0;
  toSerial.vMotor[0] = toSerial.vMotor[1] = toSerial.vMotor[2] = toSerial.vMotor[3] = 0;

  setID();

  while (toNewPoint())
    ;
  for (int i = 0; i < 4; i++) {
    allPositions[i] = 0;
  }
  for (int i = 0; i < mazeSizeX; i++) {
    for (int j = 0; j < mazeSizeY; j++) {
      for (int n = 0; n < mazeSizeZ; n++) {
        maze[i][j][n] = 0;
      }
    }
  }
  EEPROM.put(0, maze);
  EEPROM.put(sizeof(maze), allPositions);
  myServo.write(srednServo);
  delay(500);
  myServo.detach();
  tft.fillRect(0, 0, 128, 128 / 3, 0xFFFF);
  tft.fillRect(0, 128 / 3, 128, 128 * 2 / 3, 0x001F);
  tft.fillRect(0, 128 * 2 / 3, 128, 128, 0xF800);
}

void loop() {
  rainbowFade2White(3, 3, 1);
  //Serial.println(analogRead(0));
  // first_read();
  // if(lasers[4] > lateralDist * 2) {
  //   turn(orient + 1);
  //   forward();
  // }
  // else {
  //   if(lasers[0] > minDist * 2) {
  //     forward();
  //   }
  //   else {
  //     turn(orient - 1);
  //   }
  // }
}

void rainbowFade2White(int wait, int rainbowLoops, int whiteLoops) {
  int fadeVal = 0, fadeMax = 100;

  // Hue of first pixel runs 'rainbowLoops' complete loops through the color
  // wheel. Color wheel has a range of 65536 but it's OK if we roll over, so
  // just count from 0 to rainbowLoops*65536, using steps of 256 so we
  // advance around the wheel at a decent clip.
  for (uint32_t firstPixelHue = 0; firstPixelHue < rainbowLoops * 65536;
       firstPixelHue += 256) {

    for (int i = 0; i < strip.numPixels(); i++) {  // For each pixel in strip...

      // Offset pixel hue by an amount to make one full revolution of the
      // color wheel (range of 65536) along the length of the strip
      // (strip.numPixels() steps):
      uint32_t pixelHue = firstPixelHue + (i * 65536L / strip.numPixels());

      // strip.ColorHSV() can take 1 or 3 arguments: a hue (0 to 65535) or
      // optionally add saturation and value (brightness) (each 0 to 255).
      // Here we're using just the three-argument variant, though the
      // second value (saturation) is a constant 255.
      strip.setPixelColor(i, strip.gamma32(strip.ColorHSV(pixelHue, 255,
                                                          255 * fadeVal / fadeMax)));
    }

    strip.show();
    delay(wait);

    if (firstPixelHue < 65536) {                                 // First loop,
      if (fadeVal < fadeMax) fadeVal++;                          // fade in
    } else if (firstPixelHue >= ((rainbowLoops - 1) * 65536)) {  // Last loop,
      if (fadeVal > 0) fadeVal--;                                // fade out
    } else {
      fadeVal = fadeMax;  // Interim loop, make sure fade is at max
    }
  }
}